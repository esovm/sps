;.buffer: The lexer reads its input from a buffer.
;
;.indexing: To make the code ammenable to reasonably efficient execution
; under Scheme the position of the current character and end of the buffer 
; as integer indices rather than character addresses.
;

                             ; SPSLEXER
(define sps:lexer::tag-value #x5657E8E4)

(define (sps:lexer::tag l)
  (sps:word-vector:ref l 0))
(define (sps:lexer::tag! l v)
  (sps:word-vector:set! l 0 v))

(define (sps:lexer? t) 
  (= (sps:lexer::tag t) sps:lexer::tag-value))

; <code>sps:lexer::i</code> is the ordinal of the current character in the
; lexer buffer and it should range over [0..end].

(define (sps:lexer::i l)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:ref l 1))
(define (sps:lexer::i! l v)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:set! l 1 v))


; <code>sps:lexer::end</code> is the ordinal of the position after the
; last character in <code>sps:lexer::buffer</code>.  For example, if the
; buffer has 10 characters (at positions 0 through 9) then 
; <code>end</code> will be 10.

(define (sps:lexer::end l)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:ref l 2))
(define (sps:lexer::end! l v)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:set! l 2 v))


; <code>sps:lexer::line</code> is the line number of the the current lexeme.
; This ranges over [1..].

(define (sps:lexer::line l)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:ref l 3))
(define (sps:lexer::line! l v)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:set! l 3 v))


; <code>sps:lexer::column</code> is the column that the current lexeme
; starts in.  This ranges over [0..].

(define (sps:lexer::column l)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:ref l 4))
(define (sps:lexer::column! l v)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:set! l 4 v))


; <code>sps:lexer::input</code> and <code>sps:lexer::input-ops</code> are
; the source of the characters in <code>sps:lexer::buffer</code>.  
; Together they satisfy the <code>sps:input</code> interface.

(define (sps:lexer::input l)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:ref l 5))
(define (sps:lexer::input! l v)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:set! l 5 v))

(define (sps:lexer::input-ops l)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:ref l 6))
(define (sps:lexer::input-ops! l v)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:set!  l 6 v))


; <code>sps:lexer::buffer</code> points to a vector containing characters.
; This is indexed by <code>sps:lexer::i</code>.

(define (sps:lexer::buffer l)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:ref l 7))
(define (sps:lexer::buffer! l v)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:set! l 7 v))

(define (sps:lexer:state l)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:ref l 8))
(define (sps:lexer::state! l v)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:set! l 8 v))

(define (sps:lexer::errors l)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:ref l 9))
(define (sps:lexer::errors! l v)
  (sps:assert (sps:lexer? l))
  (sps:word-vector:set! l 9 v))

(define sps:lexer:size (* 10 sps:bytes-per-word))

(define (sps:lexer::dump l)
  (sps:assert (sps:lexer? l))
  (let ((op (sps:io:stdout)))
    (sps:and
      (sps:io:print:string op "LEXER - ")
      (sps:io:print:hex-int op l)
      (sps:io:newline op)
      (sps:io:print:string op "  i         = ")
      (sps:io:print:int op (sps:lexer::i l))
      (sps:io:newline op)
      (sps:io:print:string op "  end       = ")
      (sps:io:print:int op (sps:lexer::end l))
      (sps:io:newline op)
      (sps:io:print:string op "  line      = ")
      (sps:io:print:int op (sps:lexer::line l))
      (sps:io:newline op)
      (sps:io:print:string op "  column    = ")
      (sps:io:print:int op (sps:lexer::column l))
      (sps:io:newline op)
      (sps:io:print:string op "  input     = ")
      (sps:io:print:int op (sps:lexer::input l))
      (sps:io:newline op)
      (sps:io:print:string op "  input-ops = ")
      (sps:io:print:hex-int op (sps:lexer::input-ops l))
      (sps:io:newline op)
      (sps:io:print:string op "  buffer    = ")
      (sps:io:print:hex-int op (sps:lexer::buffer l))
      (sps:io:newline op)
      (sps:io:print:string op "  state     = ")
      (sps:io:print:hex-int op (sps:lexer:state l))
      (sps:io:newline op)
      (sps:io:print:string op "  errors    = ")
      (sps:io:print:hex-int op (sps:lexer::errors l))
      (sps:io:newline op))))


(define sps:lexer::id-body 
  (+ (+ sps:char-map:id sps:char-map:digit)
     (+ sps:char-map:period sps:char-map:sign)))


; <delimiter> in 7.1.1
(define sps:lexer::terminator 
  (+ (+ (+ sps:char-map:ws sps:char-map:str)
        (+ sps:char-map:list-open sps:char-map:list-close))
     sps:char-map:comment))


(define (sps:lexer:open lexer input input-ops errors)
  (let ((buffer ((sps:input:buffer input-ops) input)))
    (sps:lexer::tag! lexer sps:lexer::tag-value)
    (sps:lexer::i! lexer 0)
    (sps:lexer::end! lexer 0)
    (sps:lexer::line! lexer 1)
    (sps:lexer::column! lexer 0)
    (sps:lexer::input! lexer input)
    (sps:lexer::input-ops! lexer input-ops)
    (sps:lexer::buffer! lexer buffer)
    (sps:lexer::errors! lexer errors)))


(define (sps:lexer::id l actions state id-start start-column)
  (let ((buffer (sps:lexer::buffer l))
        (line (sps:lexer::line l))
        (id (sps:lexer:action:id actions)))
    (let restart ((end (sps:lexer::end l))
                  (id-start id-start))
      (let start ((i (sps:lexer::i l)) (column (sps:lexer::column l)))
        (if (< i end)
            (let* ((cc (sps:byte-vector:ref buffer i))
                   (cm (sps:word-vector:ref sps:char-map:map cc)))
              ;(display "ID i = ") (display i)
              ;(display " buffer[i] = ") (display cc)
              ;(display " code = ") (display cm) (newline)
              (cond ((sps:word:and? cm sps:lexer::id-body)
                     (start (+ i 1) (+ column 1)))
                    ((sps:word:and? cm sps:lexer::terminator)
                     (sps:lexer::i! l i)
                     (sps:lexer::column! l column)
                     (id l state buffer id-start i line start-column))
                    (else
                     (let* ((error-ops (sps:lexer::errors l))
                            (bad-char (sps:lexer:error:bad-char error-ops)))
                       (sps:lexer::i! l i)
                       (sps:lexer::column! l column)
                       (bad-char l cc line column)))))
            (let ((id-chunk (sps:lexer:action:id-chunk actions))
                  (input (sps:lexer::input l))
                  (input-ops (sps:lexer::input-ops l)))
              (id-chunk l state buffer id-start i line start-column)
              (let ((n-read ((sps:input:refill input-ops) input)))
                (sps:lexer::i! l 0)
                (sps:lexer::end! l n-read)
                (sps:lexer::column! l column)
                (if (not (= n-read 0))
                    (restart n-read 0)
                    (id l state buffer 0 0 line start-column)))))))))


(define sps:lexer::zero (char->integer #\0))

(define (sps:lexer::possible-int l actions state v neg?
                                 have-digit? start-column)
  (let ((line (sps:lexer::line l)))
    (if (and (not have-digit?) (= (sps:lexer::column l) start-column))
        (let* ((error-ops (sps:lexer::errors l))
               (sign-no-digit (sps:lexer:error:sign-no-digit error-ops)))
          (sign-no-digit l start-column))
        (let ((int (sps:lexer:action:int actions))
              (v (if neg? (- 0 v) v)))
          (int l state v line start-column)))))


(define (sps:lexer::int l actions state iv neg? have-digit? start-column)
  (let ((buffer (sps:lexer::buffer l)))
    (let restart ((end (sps:lexer::end l)) (iv iv))
      (let start ((i (sps:lexer::i l))
                  (column (sps:lexer::column l))
                  (v iv))
        (if (< i end)
            (let* ((cc (sps:byte-vector:ref buffer i))
                   (cm (sps:word-vector:ref sps:char-map:map cc)))
              ;(display "INT i = ") (display i)
              ;(display " buffer[i] = ") (display cc)
              ;(display " code = ") (display cm) (newline)
              (cond ((sps:word:and? cm sps:char-map:digit)
                     (let ((dv (- cc sps:lexer::zero)))
                       (start (+ i 1) (+ column 1) (+ (* v 10) dv))))
                    ((sps:word:and? cm sps:lexer::terminator)
                     (sps:lexer::i! l i)
                     (sps:lexer::column! l column)
                     (sps:lexer::possible-int l actions state v neg?
                                              have-digit? start-column))
                    (else
                     (let* ((error-ops (sps:lexer::errors l))
                            (bad-char (sps:lexer:error:bad-char error-ops))
                            (line (sps:lexer::line l)))
                       (sps:lexer::i! l i)
                       (sps:lexer::column! l column)
                       (bad-char l cc line column)))))
            (let* ((input (sps:lexer::input l))
                   (input-ops (sps:lexer::input-ops l))
                   (n-read ((sps:input:refill input-ops) input)))
              (sps:lexer::i! l 0)
              (sps:lexer::end! l n-read)
              (sps:lexer::column! l column)
              (if (not (= n-read 0))
                  (restart n-read v)
                  (sps:lexer::possible-int l actions state v neg?
                                           have-digit? start-column))))))))

(define (sps:lexer::int-or-peculiar l actions state neg? id-start start-column)
  (let ((buffer (sps:lexer::buffer l)))
    (let restart ((i (+ 1 id-start)) (end (sps:lexer::end l)))
      (if (< i end)
          (let* ((cc (sps:byte-vector:ref buffer i))
                 (cm (sps:word-vector:ref sps:char-map:map cc)))
            (if (sps:word:and? cm sps:lexer::terminator)
                (let ((id (sps:lexer:action:id actions))
                      (line (sps:lexer::line l)))
                  (id l state buffer id-start i line start-column))
                (sps:lexer::int l actions state 0 neg? #f start-column)))
          (let ((id-chunk (sps:lexer:action:id-chunk actions))
                (input (sps:lexer::input l))
                (input-ops (sps:lexer::input-ops l))
                (line (sps:lexer::line l)))
            (id-chunk l state buffer id-start i line start-column)
            (let ((n-read ((sps:input:refill input-ops) input)))
              (sps:lexer::i! l 0)
              (sps:lexer::end! l n-read)
              (if (not (= n-read 0))
                  (restart 0 n-read)
                  (let ((id (sps:lexer:action:id actions)))
                    (id l state buffer 0 0 line start-column)))))))))


(define (sps:lexer::str l actions state str-start start-line start-column)
  (let ((buffer (sps:lexer::buffer l))
        (str (sps:lexer:action:str actions)))
    (let restart ((end (sps:lexer::end l)) (str-start str-start))
      (let start ((i (sps:lexer::i l))
                  (line (sps:lexer::line l))
                  (column (sps:lexer::column l)))
        (if (< i end)
            (let* ((cc (sps:byte-vector:ref buffer i))
                   (c (integer->char cc))
                   (cm (sps:word-vector:ref sps:char-map:map cc)))
              ;(display "STR i = ") (display i)
              ;(display " buffer[i] = ") (display cc)
              ;(display " code = ") (display cm) (newline)
              (cond ((sps:word:and? cm sps:char-map:str)
                     (sps:lexer::i! l (+ i 1))
                     (sps:lexer::line! l line)
                     (sps:lexer::column! l (+ column 1))
                     (str l state buffer str-start i start-line start-column))
                    ((sps:word:and? cm sps:char-map:newline)
                     (start (+ i 1) (+ line 1) 0))
                    ((char=? c #\\)
                     (let ((str-chunk (sps:lexer:action:str-chunk actions))
                           (input (sps:lexer::input l))
                           (input-ops (sps:lexer::input-ops l))
                           (ni (+ i 1)))
                       (str-chunk l state buffer str-start i start-line start-column)
                       (if (< ni end)
                           (begin
                             (sps:lexer::i! l (+ i 2))
                             (sps:lexer::column! l (+ column 2))
                             (restart end ni))
                           (let ((n-read ((sps:input:refill input-ops) input)))
                             (sps:lexer::i! l 1)
                             (sps:lexer::end! l n-read)
                             (sps:lexer::column! l (+ column 2))
                             (if (not (= n-read 0))
                                 (restart n-read 0)
                                 (let* ((eo (sps:lexer::errors l))
                                        (bad-str (sps:lexer:error:runaway-str eo)))
                                   (bad-str l line column)))))))
                    (else
                     (start (+ i 1) line (+ column 1)))))
            (let ((str-chunk (sps:lexer:action:str-chunk actions))
                  (input (sps:lexer::input l))
                  (input-ops (sps:lexer::input-ops l)))
              (str-chunk l state buffer str-start i start-line start-column)
              (let ((n-read ((sps:input:refill input-ops) input)))
                (sps:lexer::i! l 0)
                (sps:lexer::end! l n-read)
                (sps:lexer::column! l column)
                (if (not (= n-read 0))
                    (restart n-read 0)
                    (let* ((error-ops (sps:lexer::errors l))
                           (bad-str (sps:lexer:error:runaway-str error-ops)))
                      (bad-str l line column))))))))))


(define-forward (sps:lexer:lex l actions state))

(define (sps:lexer::comment l actions state)
  (let ((buffer (sps:lexer::buffer l)))
    (let restart ((end (sps:lexer::end l)))
      (let start ((i (sps:lexer::i l)) (column (sps:lexer::column l)))
        (if (< i end)
            (let* ((cc (sps:byte-vector:ref buffer i))
                   (cm (sps:word-vector:ref sps:char-map:map cc)))
              ;(display "COMMENT i = ") (display i)
              ;(display " buffer[i] = ") (display cc)
              ;(display " code = ") (display cm) (newline)
              (if (sps:word:and? cm sps:char-map:newline)
                  (begin
                    (sps:lexer::i! l (+ i 1))
                    (sps:lexer::line! l (+ (sps:lexer::line l) 1))
                    (sps:lexer::column! l 0)
                    (sps:lexer:lex l actions state))
                  (start (+ i 1) (+ column 1))))
            (let* ((input (sps:lexer::input l))
                   (input-ops (sps:lexer::input-ops l))
                   (n-read ((sps:input:refill input-ops) input)))
              (sps:lexer::i! l 0)
              (sps:lexer::end! l n-read)
              (sps:lexer::column! l column)
              (if (not (= n-read 0))
                  (restart n-read)
                  (let ((end (sps:lexer:action:end actions))
                        (line (sps:lexer::line l)))
                    (end l line column)))))))))

(define (sps:lexer::boolean l actions state v start-column)
  (let ((buffer (sps:lexer::buffer l))
        (line (sps:lexer::line l)))
    (let restart ((i (sps:lexer::i l)) (end (sps:lexer::end l)))
      (if (< i end)
          (let* ((cc (sps:byte-vector:ref buffer i))
                 (cm (sps:word-vector:ref sps:char-map:map cc)))
            ;(display "# i = ") (display i) (newline)
            (if (sps:word:and? cm sps:lexer::terminator)
                (let ((boolean (sps:lexer:action:boolean actions)))
                  (boolean l state v line start-column))
                (let* ((error-ops (sps:lexer::errors l))
                       (bad-boolean (sps:lexer:error:bad-boolean error-ops))
                       (column (sps:lexer::column l)))
                  (bad-boolean l v cc line start-column column))))
          (let* ((input (sps:lexer::input l))
                 (input-ops (sps:lexer::input-ops l))
                 (n-read ((sps:input:refill input-ops) input)))
            (sps:lexer::i! l 0)
            (sps:lexer::end! l n-read)
            (if (not (= n-read 0))
                (restart 0 n-read)
                (let ((boolean (sps:lexer:action:boolean actions)))
                  (boolean l state v line start-column))))))))


; pre: (and (char=? (- (sps:lexer::i l) 1) #\\ )
;           (= (+ start-column 1) (sps:lexer::column l)))

(define (sps:lexer::char l actions state start-column)
  (let ((buffer (sps:lexer::buffer l))
        (line (sps:lexer::line l)))
    (let restart ((i (sps:lexer::i l)) (end (sps:lexer::end l)))
      (if (< i end)
          (let ((scanned-char (sps:byte-vector:ref buffer i)))
            ;(display "CHAR i = ") (display i)
            ;(display " buffer[i] = ") (display scanned-char) (newline)
            (let restart ((i (+ i 1))
                          (end end)
                          (column (+ (sps:lexer::column l) 1)))
              (if (< i end)
                  (let* ((cc (sps:byte-vector:ref buffer i))
                         (cm (sps:word-vector:ref sps:char-map:map cc)))
                    (sps:lexer::i! l i)
                    (sps:lexer::column! l column)
                    (if (sps:word:and? cm sps:lexer::terminator)
                        (let ((char (sps:lexer:action:char actions)))
                          (char l state scanned-char line start-column))
                        (let* ((error-ops (sps:lexer::errors l))
                               (error (sps:lexer:error:xxx-char error-ops))
                               (line (sps:lexer::line l)))
                          (error l cc start-column line column))))
                  (let* ((input (sps:lexer::input l))
                         (input-ops (sps:lexer::input-ops l))
                         (n-read ((sps:input:refill input-ops) input)))
                    (sps:lexer::i! l 0)
                    (sps:lexer::end! l n-read)
                    (sps:lexer::column! l column)
                    (if (not (= n-read 0))
                        (restart 0 n-read column)
                        (let ((char (sps:lexer:action:char actions)))
                          (char l state scanned-char line start-column)))))))
          (let* ((input (sps:lexer::input l))
                 (input-ops (sps:lexer::input-ops l))
                 (n-read ((sps:input:refill input-ops) input)))
            (sps:lexer::i! l 0)
            (sps:lexer::end! l n-read)
            (if (not (= n-read 0))
                (restart 0 n-read)
                (let* ((error-ops (sps:lexer::errors l))
                       (bad-char (sps:lexer:error:unterminated-char error-ops))
                       (line (sps:lexer::line l)))
                  (bad-char l line start-column))))))))


; FIXME
(define (sps:lexer::char-name l actions state start-column)
  #f)

(define (sps:lexer::possible-radix-int l actions state v start-column radix)
  (let ((line (sps:lexer::line l)))
    (if (not (= (sps:lexer::column l) start-column))
        (let ((int (sps:lexer:action:int actions)))
          (int l state v line start-column))
        (let* ((error-ops (sps:lexer::errors l))
               (radix-no-digit (sps:lexer:error:radix-no-digit error-ops)))
          (radix-no-digit l radix line start-column)))))


(define (sps:lexer::radix-int l actions state start-column radix)
  (let ((buffer (sps:lexer::buffer l)))
    (let restart ((end (sps:lexer::end l)) (v 0))
      (let start ((i (sps:lexer::i l))
                  (column (sps:lexer::column l))
                  (v v))
        (if (< i end)
            (let* ((cc (sps:byte-vector:ref buffer i))
                   (cm (sps:word-vector:ref sps:char-map:map cc))
                   (cv (- cc sps:lexer::zero)))
              ;(display "#INT i = ") (display i)
              ;(display " buffer[i] = ") (display cc)
              ;(display " code = ") (display cm)
              ;(display " v = ") (display v)
              ;(display " cv = ") (display cv)
              ;(newline)
              (cond ((and (sps:word:and? cm sps:char-map:digit) (< cv radix))
                     (start (+ i 1) (+ column 1) (+ (* v radix) cv)))
                    ((sps:word:and? cm sps:lexer::terminator)
                     (sps:lexer::i! l i)
                     (sps:lexer::column! l column)
                     (sps:lexer::possible-radix-int l actions state
                                                    v start-column radix))
                    (else
                     (let* ((error-ops (sps:lexer::errors l))
                            (bad-char (sps:lexer:error:bad-char error-ops))
                            (line (sps:lexer::line l)))
                       (sps:lexer::i! l i)
                       (sps:lexer::column! l column)
                       (bad-char l cc line column)))))
            (let* ((input (sps:lexer::input l))
                   (input-ops (sps:lexer::input-ops l))
                   (n-read ((sps:input:refill input-ops) input)))
              (sps:lexer::i! l 0)
              (sps:lexer::end! l n-read)
              (sps:lexer::column! l column)
              (if (not (= n-read 0))
                  (restart n-read v)
                  (sps:lexer::possible-radix-int l actions state v 
                                                 start-column radix))))))))


(define (sps:lexer::hex->int cv)
  (let ((upper (char->integer #\A))
        (lower (char->integer #\a)))
    (+ 10 (if (< cv lower) (- cv upper) (- cv lower)))))


(define (sps:lexer::hex-int l actions state start-column)
  (let ((buffer (sps:lexer::buffer l)))
    (let restart ((end (sps:lexer::end l)) (v 0))
      (let start ((i (sps:lexer::i l))
                  (column (sps:lexer::column l))
                  (v v))
        (if (< i end)
            (let* ((cc (sps:byte-vector:ref buffer i))
                   (cm (sps:word-vector:ref sps:char-map:map cc))
                   (cv (- cc sps:lexer::zero)))
              ;(display "#HEX-INT i = ") (display i)
              ;(display " buffer[i] = ") (display cc)
              ;(display " code = ") (display cm)
              ;(display " v = ") (display v)
              ;(display " cv = ") (display cv)
              ;(newline)
              (cond ((and (sps:word:and? cm sps:char-map:digit))
                     (start (+ i 1) (+ column 1) (+ (* v 16) cv)))
                    ((and (sps:word:and? cm sps:char-map:hex-digit))
                     (let ((cv (sps:lexer::hex->int cv)))
                       (start (+ i 1) (+ column 1) (+ (* v 16) cv))))
                    ((sps:word:and? cm sps:lexer::terminator)
                     (sps:lexer::i! l i)
                     (sps:lexer::column! l column)
                     (sps:lexer::possible-radix-int l actions state
                                                    v start-column 16))
                    (else
                     (let* ((error-ops (sps:lexer::errors l))
                            (bad-char (sps:lexer:error:bad-char error-ops))
                            (line (sps:lexer::line l)))
                       (sps:lexer::i! l i)
                       (sps:lexer::column! l column)
                       (bad-char l cc line column)))))
            (let* ((input (sps:lexer::input l))
                   (input-ops (sps:lexer::input-ops l))
                   (n-read ((sps:input:refill input-ops) input)))
              (sps:lexer::i! l 0)
              (sps:lexer::end! l n-read)
              (sps:lexer::column! l column)
              (if (not (= n-read 0))
                  (restart n-read v)
                  (sps:lexer::possible-radix-int l actions state v 
                                                 start-column 16))))))))


(define (sps:lexer::hash l actions state start-column)
  (let ((buffer (sps:lexer::buffer l))
        (line (sps:lexer::line l)))
    (let restart ((i (sps:lexer::i l)) (end (sps:lexer::end l)))
      (if (< i end)
          (let* ((c (integer->char (sps:byte-vector:ref buffer i))))
            ;(display "# i = ") (display i) (newline)
            (sps:lexer::i! l (+ i 1))
            (sps:lexer::column! l (+ (sps:lexer::column l) 1))
            (case c
              ((#\t) (sps:lexer::boolean l actions state #t start-column))
              ((#\f) (sps:lexer::boolean l actions state #f start-column))
              ((#\!) (sps:lexer::comment l actions state))
              ((#\\) (sps:lexer::char l actions state start-column))
              ((#\b) (sps:lexer::radix-int l actions state start-column 2))
              ((#\o) (sps:lexer::radix-int l actions state start-column 8))
              ((#\x) (sps:lexer::hex-int l actions state start-column))
              ((#\d) (sps:lexer::radix-int l actions state start-column 10))
              (else  (sps:lexer::char-name l actions state start-column))))
          (let* ((input (sps:lexer::input l))
                 (input-ops (sps:lexer::input-ops l))
                 (n-read ((sps:input:refill input-ops) input)))
            (sps:lexer::i! l 0)
            (sps:lexer::end! l n-read)
            (if (not (= n-read 0))
                (restart 0 n-read)
                (let* ((error-ops (sps:lexer::errors l))
                       (lonely-hash (sps:lexer:error:lonely-hash error-ops)))
                  (lonely-hash l line start-column))))))))
  

(define (sps:lexer:lex l actions state)
  (let ((buffer (sps:lexer::buffer l)))
    (let restart ((end (sps:lexer::end l)))
      (let start ((i (sps:lexer::i l))
                  (line (sps:lexer::line l))
                  (column (sps:lexer::column l)))
        (if (< i end)
            (let* ((cc (sps:byte-vector:ref buffer i))
                   (c (integer->char cc))
                   (cm (sps:word-vector:ref sps:char-map:map cc)))
              ;(display "LEX i = ") (display i)
              ;(display " buffer[i] = ") (display cc)
              ;(display " code = ") (display cm) (newline)
              (cond ((sps:word:and? cm sps:char-map:ws)
                     (if (sps:word:and? cm sps:char-map:newline)
                         (start (+ i 1) (+ line 1) 0)
                         (start (+ i 1) line (+ column 1))))
                    ((sps:word:and? cm sps:char-map:id)
                     (sps:lexer::i! l (+ i 1))
                     (sps:lexer::line! l line)
                     (sps:lexer::column! l (+ column 1))
                     (sps:lexer::id l actions state i column))
                    ((sps:word:and? cm sps:char-map:list-open)
                     (let ((list-open (sps:lexer:action:list-open actions)))
                       (sps:lexer::i! l (+ i 1))
                       (sps:lexer::line! l line)
                       (sps:lexer::column! l (+ column 1))
                       (list-open l state line column)))
                    ((sps:word:and? cm sps:char-map:list-close)
                     (let ((list-close (sps:lexer:action:list-close actions)))
                       (sps:lexer::i! l (+ i 1))
                       (sps:lexer::line! l line)
                       (sps:lexer::column! l (+ column 1))
                       (list-close l state line column)))
                    ((sps:word:and? cm sps:char-map:comment)
                     (sps:lexer::i! l (+ i 1))
                     (sps:lexer::line! l line)
                     (sps:lexer::column! l (+ column 1))
                     (sps:lexer::comment l actions state))
                    ((sps:word:and? cm sps:char-map:digit)
                     (let ((v (- cc sps:lexer::zero)))
                       (sps:lexer::i! l (+ i 1))
                       (sps:lexer::line! l line)
                       (sps:lexer::column! l (+ column 1))
                       (sps:lexer::int l actions state v #f #t column)))
                    ((sps:word:and? cm sps:char-map:str)
                     (sps:lexer::i! l (+ i 1))
                     (sps:lexer::line! l line)
                     (sps:lexer::column! l (+ column 1))
                     (sps:lexer::str l actions state (+ i 1) line column))
                    ((sps:word:and? cm sps:char-map:sign)
                     (sps:lexer::i! l (+ i 1))
                     (sps:lexer::line! l line)
                     (sps:lexer::column! l (+ column 1))
                     (sps:lexer::int-or-peculiar l actions state (char=? c #\-)
                                                 i column))
                    ((char=? c #\#)
                     (sps:lexer::i! l (+ i 1))
                     (sps:lexer::line! l line)
                     (sps:lexer::column! l (+ column 1))
                     (sps:lexer::hash l actions state column))
                    (else
                     (let* ((error-ops (sps:lexer::errors l))
                            (bad-char (sps:lexer:error:bad-char error-ops)))
                       (sps:lexer::i! l i)
                       (sps:lexer::line! l line)
                       (sps:lexer::column! l column)
                       (bad-char l cc line column)))))
            (let* ((input (sps:lexer::input l))
                   (input-ops (sps:lexer::input-ops l))
                   (n-read ((sps:input:refill input-ops) input)))
              (sps:lexer::i! l 0)
              (sps:lexer::end! l n-read)
              (sps:lexer::line! l line)
              (sps:lexer::column! l column)
              (if (not (= n-read 0))
                  (restart n-read)
                  ((sps:lexer:action:end actions) l state line column))))))))
